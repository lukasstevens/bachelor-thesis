% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Ergebnisse}\label{chapter:ergebnisse}
Im Folgenden wird die \Cpp\hyp Implementierung experimentell evaluiert.
Die zwei zentralen Kenngrößen des Algorithmus sind die Laufzeit und die Schnittkosten der ausgegebenen Partitionierung.
Dabei werden die Schnittkosten, mit denen verglichen, die durch die Heuristiken METIS~\cite{KK98} und KaHIP~\cite{SS13} erreicht werden.
Da der Algorithmus dieser Arbeit ausschließlich auf Bäumen arbeitet, wird zunächst das Verhalten dieser Kenngrößen in Abhängigkeit der Eingabeparameter auf Bäumen untersucht.
Anschließend werden die Schnittkosten auf generellen Graphen untersucht.
Dazu wird zu einem Graph ein entsprechender Baum generiert und der Algorithmus wird auf den Baum angewandt.
Danach wird die Partitionierung des Baums in eine Partitionierung des Graphen umgewandelt.

\section{Bäume}
Es wurden vier verschiedene Heuristiken verwendet, um zufällige Bäume zu generieren.
Die erste Heuristik wird im Weiteren als Random Attachment bezeichnet. 
Ein Baum mit $n$ Knoten wird generiert, indem mit einem Knoten gestartet wird und iterativ Blätter an zufällige Knoten des Baums angehängt werden, bis die gewünschte Knotenanzahl $n$ erreicht ist.
Eine weitere Heuristik, die eine abgewandelte Version des Random Attachments ist, wird als Preferrential Attachment bezeichnet.
Dabei wird eine neues Blatt nicht zufällig mit einer uniformen Verteilung an einen Knoten des Baums angehängt, sondern die Wahrscheinlichkeit ist proportional zum Grad des Knotens.
Bei den beiden oben genannten Heuristiken kann zusätzlich noch ein Maximalgrad für die Knoten des Baums festgelegt werden.
Die dritte Heuristik sind sogenannte Fat Trees.
Für diese Heuristik wird wiederum mit einem Knoten in Level $0$ gestartet.
Für das Level $l \geq 1$ des Baums wird aus einer gegebenen Menge zufällig eine Zahl $k$ ausgewählt.
Dann werden an alle Knoten des Levels $l - 1$ genau $k$ Kinder angehängt.
Dies wird wiederholt, bis der Baum die gewünschte Anzahl an Knoten hat. 
Dementsprechend kann es sein, dass das letzte Level nicht vollständig mit Knoten gefüllt ist.
Fat Trees sind eine Verallgemeinerung von fast vollständigen $k$\hyp ären Bäumen.
Wir erhalten einen fast vollständigen $k$\hyp ären Baum, indem wir die Menge der möglichen Kinderanzahlen des Fat Trees auf $\{k\}$ setzen.
\todo[inline]{Eventuell Visualisierungen}

\subsection{Laufzeit}
Um die Laufzeit des Algorithmus zu analysieren, wurde wiederholt ein Parameter gewählt, dessen Auswirkung auf die Laufzeit untersucht werden soll.
Die anderen Parameter wurden festgesetzt und bleiben konstant.
Dann wurde der gewählte Parameter schrittweise verändert.
Um Schwankungen auszugleichen, wurden für jede Kombination der Parameter 20 verschiedene Bäume mit den oben genannten Heuristiken generiert und die Laufzeit für jeden Baum gemessen.
Dabei wurde die Anzahl der Kinder des Fat Trees aus der Menge $\{2, \ldots, 10\}$ gewählt und als $k$\hyp ärer Baum wurde ein Binärbaum gewählt.
Des Weiteren wurden für die übrigen Parameter jeweils drei verschieden Konfigurationen gewählt.
In den Abbildungen~\ref{fig:runnodes},~\ref{fig:runimb},~\ref{fig:runkparts} und~\ref{fig:rundeg} werden die gemessenen Zeiten mit Boxplots dargestellt.
Ein Boxplot besteht aus einer oberen Antenne, einer unteren Antenne, dem oberen Quartil, dem unteren Quartil und dem Median.
\todo{Was soll mit den Ausreißern gemacht werden?} Die obere Antenne und die untere Antenne stellen jeweils das Maximum beziehungsweise das Minimum der gemessenen Werte dar, falls es keine Ausreißer gibt, die weit vom Rest der Werte entfernt sind.
In den Messergebnissen kamen in fast allen Fällen pro 20 Durchläufen höchstens drei Ausreißer nach oben vor.
Nur für kleines $\varepsilon$ kamen bis zu fünf Ausreißer vor.
Weiterhin liegen $75\%$ der gemessen Werte unterhalb des oberen Quartils, während $25\%$ unterhalb des unteren Quartils liegen.
Das obere und untere Quartil werden zu einer Box zusammengefasst.
Zuletzt sind $50\%$ der Werte kleiner als der Median, welcher durch einen Querstrich dargestellt wird.

Abbildung~\ref{fig:runnodes} zeigt die Laufzeit im Millisekunden in Abhängigkeit der Knotenanzahl $n$ des Baums.
Für jede Heuristik wurde eine Messreihe mit verschieden Konfigurationen der übrigen Parametern angelegt.
Dabei wird die jeweilige Heuristik in der Graphüberschrift genannt und den verschiedenen Parameterkonfigurationen sind unterschiedliche Farben zugewiesen. 
\begin{figure}[t]
    \centering
    \scalebox{0.8}{\includestandalone{figures/trees/runtime/node_count}}
    \caption{Laufzeit in Abhängigkeit der Knotenanzahl}\label{fig:runnodes}
\end{figure}

Die Abbildung~\ref{fig:runimb} ist aufgebaut wie die vorherige Abbildung, zeigt jedoch die Laufzeit in Abhängigkeit des Ungleichgewichts $\varepsilon$.
Ein Ungleichgewicht von $\varepsilon$ bedeutet, dass jede Partition der ermittelten Partitionierung höchstens eine Größe von $(1 + \varepsilon) \ceil{n/k}$ hat.
Wie oben erwähnt, sind die Werte für kleines $\varepsilon$ weiter gestreut.
\begin{figure}[t]
    \centering
    \scalebox{0.8}{\includestandalone{figures/trees/runtime/imbalance}}
    \caption{Laufzeit in Abhängigkeit des Ungleichgewichts}\label{fig:runimb}
\end{figure}

In Abbildung~\ref{fig:runkparts} ist die Laufzeit in Abhängigkeit der Anzahl an Partitionen $k$ zu sehen.
Auch hier führt die Wahl von $\varepsilon=1/5$ zu einer größeren Streuung.
Weiterhin gilt zu bemerken, dass die Laufzeit für steigendes $k$ zunächst zunimmt und dann wieder abnimmt.
\begin{figure}
    \centering
    \scalebox{0.8}{\includestandalone{figures/trees/runtime/kparts}}
    \caption{Laufzeit in Abhängigkeit der Teilanzahl}\label{fig:runkparts}
\end{figure}

Die letzte Abbildung~\ref{fig:rundeg} visualisiert die Laufzeit in Abhängigkeit des Maximalgrads.
Hierbei wurde die Heuristik Random Attachment weggelassen, da es unwahrscheinlich ist, dass der Maximalgrad bei größeren Werten erreicht wird.
Beim Fat Tree wurde für die Mindestanzahl an Kindern weiterhin zwei gewählt, während die Maximalanzahl durch den Maximalgrad gegeben ist.
Anstatt eines Binärbaums wurde ein $k$\hyp ärer Baum betrachtet und die Entwicklung der Laufzeit mit wachsendem $k$ untersucht.
Wie zu sehen ist nimmt die Laufzeit mit wachsendem Maximalgrad ab.
\begin{figure}
    \centering
    \scalebox{0.8}{\includestandalone{figures/trees/runtime/max_degree}}
    \caption{Laufzeit in Abhängigkeit des Maximalgrads}\label{fig:rundeg}
\end{figure}

Insgesamt ist die geringe Streuung der Werte beim Binärbaum bemerkenswert.
Des Weiteren zeichnet sich der Binärbaum durch eine höhere Laufzeit und der Fat Tree durch eine geringere Laufzeit aus.

\subsection{Lösungsqualitat}
\subsection{Graphen}
Unter Verwendung von Hierarchical Composition

