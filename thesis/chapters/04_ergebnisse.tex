% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Ergebnisse}\label{chapter:ergebnisse}
Im Folgenden wird die \Cpp\hyp Implementierung experimentell evaluiert.
Die zwei zentralen Kenngrößen des Algorithmus sind die Laufzeit und die Schnittkosten der ausgegebenen Partitionierung.
Dabei werden die Schnittkosten, mit denen verglichen, die durch die Heuristiken METIS~\cite{KK98} und KaHIP~\cite{SS13} erreicht werden.
Da der Algorithmus dieser Arbeit ausschließlich auf Bäumen arbeitet, wird zunächst das Verhalten dieser Kenngrößen in Abhängigkeit der Eingabeparameter auf Bäumen untersucht.
Anschließend werden die Schnittkosten auf generellen Graphen untersucht.
Dazu wird zu einem Graph ein entsprechender Baum generiert und der Algorithmus wird auf den Baum angewandt.
Danach wird die Partitionierung des Baumes in eine Partitionierung des Graphen umgewandelt.

\section{Bäume}
Es werden vier verschiedene Heuristiken verwendet, um zufällige Bäume zu generieren.
Die erste Heuristik wird im Weiteren als Random Attachment bezeichnet. 
Ein Baum mit $n$ Knoten wird generiert, indem mit einem Knoten gestartet wird und iterativ Blätter an zufällige Knoten des Baums angehängt werden, bis die gewünschte Knotenanzahl $n$ erreicht ist.
Eine weitere Heuristik, die eine abgewandelte Version des Random Attachments ist, wird als Preferrential Attachment bezeichnet.
Dabei wird eine neues Blatt nicht zufällig mit einer uniformen Verteilung an einen Knoten des Baums angehängt, sondern die Wahrscheinlichkeit ist proportional zum Grad des Knotens.
Bei den beiden oben genannten Heuristiken kann zusätzlich noch ein Maximalgrad für die Knoten des Baums festgelegt werden.
Die dritte Heuristik sind sogenannte Fat Trees.
Für diese Heuristik wird wiederum mit einem Knoten in Level $0$ gestartet.
Für das Level $l \geq 1$ des Baums wird aus einer gegebenen Menge zufällig eine Zahl $k$ ausgewählt.
Dann werden an alle Knoten des Levels $l - 1$ genau $k$ Kinder angehängt.
Dies wird wiederholt, bis der Baum die gewünschte Anzahl an Knoten hat. 
Dementsprechend kann es sein, dass das letzte Level nicht vollständig mit Knoten gefüllt ist.
Fat Trees sind eine Verallgemeinerung von fast vollständigen $k$\hyp ären Bäumen.
Wir erhalten einen fast vollständigen $k$\hyp ären Baum, indem wir die Menge der möglichen Kinderanzahlen des Fat Trees auf $\{k\}$ setzen.
\todo[inline]{Eventuell Visualisierungen}

\subsection{Laufzeit}

\begin{figure}
    \centering
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/node_count/rand_attach}
        }
    }
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/node_count/pref_attach}
        }
    }
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/node_count/fat}
        }
    }
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/node_count/bnary}
        }
    }
    \caption{Laufzeit in Abhängigkeit der Knotenanzahl für Random Attachement}
\end{figure}

\begin{figure}
    \centering
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/kparts/rand_attach}
        }
    }
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/kparts/pref_attach}
        }
    }
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/kparts/fat}
        }
    }
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/kparts/bnary}
        }
    }
\end{figure}

\begin{figure}
    \centering
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/imbalance/rand_attach}
        }
    }
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/imbalance/pref_attach}
        }
    }
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/imbalance/fat}
        }
    }
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/imbalance/bnary}
        }
    }
\end{figure}

\begin{figure}
    \centering
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/max_degree/pref_attach}
        }
    }
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/max_degree/fat}
        }
    }
    \subfigure{
        \centering
        \resizebox{0.45\linewidth}{!}{
            \includestandalone{figures/trees/runtime/max_degree/nary}
        }
    }
\end{figure}

\subsection{Lösungsqualitat}
\subsection{Graphen}
Unter Verwendung von Hierarchical Composition

