% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Ergebnisse}\label{chapter:ergebnisse}
Im Folgenden wird die \Cpp\hyp Implementierung experimentell evaluiert.
Die zwei zentralen Kenngrößen des Algorithmus sind die Laufzeit und die Schnittkosten der ausgegebenen Partitionierung.
Dabei werden die Schnittkosten, mit denen verglichen, die durch die Heuristiken METIS~\cite{KK98} und KaHIP~\cite{SS13} erreicht werden.
Da der Algorithmus dieser Arbeit ausschließlich auf Bäumen arbeitet, wird zunächst das Verhalten dieser Kenngrößen in Abhängigkeit der Eingabeparameter auf Bäumen untersucht.
Anschließend werden die Schnittkosten auf generellen Graphen untersucht.
Dazu wird zu einem Graph ein entsprechender Baum generiert und der Algorithmus wird auf den Baum angewandt.
Danach wird die Partitionierung des Baums in eine Partitionierung des Graphen umgewandelt.

\section{Bäume}
Es wurden vier verschiedene Heuristiken verwendet, um zufällige Bäume zu generieren.
Die erste Heuristik wird im Weiteren als Random Attachment bezeichnet. 
Ein Baum mit $n$ Knoten wird generiert, indem mit einem Knoten gestartet wird und iterativ Blätter an zufällige Knoten des Baums angehängt werden, bis die gewünschte Knotenanzahl $n$ erreicht ist.
Eine weitere Heuristik, die eine abgewandelte Version des Random Attachments ist, wird als Preferrential Attachment bezeichnet.
Dabei wird eine neues Blatt nicht zufällig mit einer uniformen Verteilung an einen Knoten des Baums angehängt, sondern die Wahrscheinlichkeit ist proportional zum Grad des Knotens.
Bei den beiden oben genannten Heuristiken kann zusätzlich noch ein Maximalgrad für die Knoten des Baums festgelegt werden.
Die dritte Heuristik sind sogenannte Fat Trees.
Für diese Heuristik wird wiederum mit einem Knoten in Level $0$ gestartet.
Für das Level $\ell \geq 1$ des Baums wird aus einer gegebenen Menge zufällig eine Zahl $d$ ausgewählt.
Dann werden an alle Knoten des Levels $\ell - 1$ genau $d$ Kinder angehängt.
Dies wird wiederholt, bis der Baum die gewünschte Anzahl an Knoten hat. 
Dementsprechend kann es sein, dass das letzte Level nicht vollständig mit Knoten gefüllt ist.
Fat Trees sind eine Verallgemeinerung von fast vollständigen $d$\hyp ären Bäumen.
Wir erhalten einen vollständig balancierten $d$\hyp ären Baum, indem wir die Menge der möglichen Kinderanzahlen des Fat Trees auf $\{d\}$ setzen.
Für alle Heuristiken werden die Kantengewichte der Bäume mit einer uniformen Zufallsverteilung aus dem Bereich $[1, 100]$ gewählt.
\todo[inline]{Eventuell Visualisierungen, Definition fast vollständiger Baum?}

\subsection{Laufzeit}\label{sec:exprun}
Um die Laufzeit des Algorithmus zu analysieren, wurde wiederholt ein Parameter gewählt, dessen Auswirkung auf die Laufzeit untersucht werden soll.
Die anderen Parameter wurden festgesetzt und bleiben konstant.
Dann wurde der gewählte Parameter schrittweise verändert.
Um Schwankungen auszugleichen, wurden für jede Kombination der Parameter 20 verschiedene Bäume mit den oben genannten Heuristiken generiert und die Laufzeit für jeden Baum gemessen.
Dabei wurde die Anzahl der Kinder des Fat Trees aus der Menge $\{2, \ldots, 10\}$ gewählt und als $d$\hyp ärer Baum wurde ein Binärbaum gewählt.
Des Weiteren wurden für die übrigen Parameter jeweils drei verschieden Konfigurationen gewählt.
Alle Zeitmessungen wurden auf einem System mit $8$ GB Arbeitsspeicher und einem Intel i7-4790k Prozessor mit einer Taktrate von $4.0$ GHz durchgeführt.

In den Abbildungen~\ref{fig:runnodes},~\ref{fig:runimb},~\ref{fig:runkparts} und~\ref{fig:rundeg} werden die gemessenen Zeiten mit Boxplots dargestellt.
Ein Boxplot besteht aus einer oberen Antenne, einer unteren Antenne, dem oberen Quartil, dem unteren Quartil und dem Median.
\todo{Was soll mit den Ausreißern gemacht werden?, Vielleicht so lassen, aber average statt median?} Die obere Antenne und die untere Antenne stellen jeweils das Maximum beziehungsweise das Minimum der gemessenen Werte dar, falls es keine Ausreißer gibt, die weit vom Rest der Werte entfernt sind.
In den Messergebnissen kamen in fast allen Fällen pro 20 Durchläufen höchstens drei Ausreißer nach oben vor.
Nur für kleines $\eps$ kamen bis zu fünf Ausreißer vor.
Weiterhin liegen $75\%$ der gemessen Werte unterhalb des oberen Quartils, während $25\%$ unterhalb des unteren Quartils liegen.
Das obere und untere Quartil werden zu einer Box zusammengefasst.
Zuletzt sind $50\%$ der Werte kleiner als der Median, welcher durch einen Querstrich dargestellt wird.

Abbildung~\ref{fig:runnodes} zeigt die Laufzeit im Millisekunden in Abhängigkeit der Knotenanzahl $n$ des Baums.
Für jede Heuristik wurde eine Messreihe mit verschieden Konfigurationen der übrigen Parametern angelegt.
Dabei wird die jeweilige Heuristik in der Graphüberschrift genannt und den verschiedenen Parameterkonfigurationen sind unterschiedliche Farben zugewiesen. 
\todo{Hier eine Tabelle für alle Heuristiken machen. Dieser kurze Test zeigt schon die $n^4$ Laufzeit.} Außerdem wurde eine weitere Messung für höhere Knotenanzahlen durchgeführt, wobei die Heuristik Preferrential Attachment verwendet wurde.
Es wurde jeweils eine Baum mit $200$, $400$ und $800$ Knoten generiert und der Algorithmus auf diese Bäume mit den Parametern $k = 2$ und $\eps = 1/3$ angewandt.
Dies führte bei $200$ Knoten zu einer Laufzeit von einer Sekunde, bei $400$ zu 16 Sekunden und bei $800$ Knoten wurde der Prozess terminiert da der Arbeitsspeicher vollständig ausgeschöpft wurde.
\begin{figure}[t]
    \centering
    \resizebox{\linewidth}{!}{\includestandalone{figures/trees/runtime/node_count}}
    \caption{Laufzeit in Abhängigkeit der Knotenanzahl\label{fig:runnodes}}
\end{figure}

Die Abbildung~\ref{fig:runimb} ist aufgebaut wie die vorherige Abbildung, zeigt jedoch die Laufzeit in Abhängigkeit des Ungleichgewichts $\eps$.
Ein Ungleichgewicht von $\eps$ bedeutet, dass jede Partition der ermittelten Partitionierung höchstens eine Größe von $(1 + \eps) \ceil{n/k}$ hat.
Wie oben erwähnt, sind die Werte für kleines $\eps$ weiter gestreut.
\begin{figure}[t]
    \centering
    \resizebox{\linewidth}{!}{\includestandalone{figures/trees/runtime/imbalance}}
    \caption{Laufzeit in Abhängigkeit des Ungleichgewichts\label{fig:runimb}}
\end{figure}

In Abbildung~\ref{fig:runkparts} ist die Laufzeit in Abhängigkeit der Anzahl an Partitionen $k$ zu sehen.
Auch hier führt die Wahl von $\eps=1/5$ zu einer größeren Streuung.
Weiterhin gilt zu bemerken, dass die Laufzeit für steigendes $k$ zunächst zunimmt und dann wieder abnimmt.
\begin{figure}
    \centering
    \includestandalone{figures/trees/runtime/kparts}
    \caption{Laufzeit in Abhängigkeit der Teilanzahl\label{fig:runkparts}}
\end{figure}

Die letzte Abbildung~\ref{fig:rundeg} visualisiert die Laufzeit in Abhängigkeit des Maximalgrads $\Delta$.
Hierbei wurde die Heuristik Random Attachment weggelassen, da es unwahrscheinlich ist, dass der Maximalgrad bei größeren Werten erreicht wird.
Beim Fat Tree wurde weiterhin zwei für die Mindestanzahl an Kindern gewählt, während die Maximalanzahl $\Delta - 1$ ist.
Anstatt eines Binärbaums wurde ein $d$\hyp ärer Baum betrachtet und die Entwicklung der Laufzeit mit wachsendem $d$ untersucht.
Wie zu sehen ist nimmt die Laufzeit mit wachsendem Maximalgrad ab.
\begin{figure}
    \centering
    \includestandalone{figures/trees/runtime/max_degree}
    \caption{Laufzeit in Abhängigkeit des Maximalgrads\label{fig:rundeg}}
\end{figure}

Insgesamt ist die geringe Streuung der Werte beim Binärbaum bemerkenswert.
Des Weiteren zeichnet sich der Binärbaum durch eine höhere Laufzeit und der Fat Tree durch eine geringere Laufzeit aus.

\subsection{Lösungsqualitat}

\begin{figure}
    \centering
    \includestandalone{figures/trees/quality/tree_heuristics}
    \caption{Relative Schnittkosten in Abhängigkeit der Baumheuristik\label{fig:treecutcost}}
\end{figure}

\subsection{Graphen}

\begin{figure}
    \centering
    \includestandalone{figures/graphs/node_count/edge_prob_rst}
    \caption{Relative Schnittkosten für die Heuristik GraphEdgeProb und RST in Abhängigkeit der Knotenanzahl $n$}
\end{figure}

\begin{figure}
    \centering
    \includestandalone{figures/graphs/node_count/edge_prob_mst}
    \caption{Relative Schnittkosten für die Heuristik GraphEdgeProb und MST in Abhängigkeit der Knotenanzahl $n$}
\end{figure}

\begin{figure}
    \centering
    \includestandalone{figures/graphs/node_count/edge_prob_decomp}
    \caption{Relative Schnittkosten für die Heuristik GraphEdgeProb und Hierarchical Decomposition in Abhängigkeit der Knotenanzahl $n$}
\end{figure}

\begin{figure}
    \centering
    \includestandalone{figures/graphs/node_count/pref_attach_rst}
    \caption{Relative Schnittkosten für die Heuristik Preferrential Attachment und RST in Abhängigkeit der Knotenanzahl $n$}
\end{figure}

\begin{figure}
    \centering
    \includestandalone{figures/graphs/node_count/pref_attach_mst}
    \caption{Relative Schnittkosten für die Heuristik Preferrential Attachment und MST in Abhängigkeit der Knotenanzahl $n$}
\end{figure}

\begin{figure}
    \centering
    \includestandalone{figures/graphs/node_count/pref_attach_decomp}
    \caption{Relative Schnittkosten für die Heuristik Preferrential Attachment und Hierarchical Decomposition in Abhängigkeit der Knotenanzahl $n$}
\end{figure}

\pagebreak

%\begin{figure}
%    \centering
%    \includestandalone{figures/graphs/imbalance/edge_prob_rst}
%    \caption{Relative Schnittkosten für die Heuristik GraphEdgeProb und RST in Abhängikeit von $\eps$}
%\end{figure}
%
%\begin{figure}
%    \centering
%    \includestandalone{figures/graphs/imbalance/edge_prob_mst}
%    \caption{Relative Schnittkosten für die Heuristik GraphEdgeProb und MST in Abhängikeit von $\eps$}
%\end{figure}

\todo[inline]{Ergebniss zu rst und mst in den Anhang?}

\begin{figure}
    \centering
    \includestandalone{figures/graphs/imbalance/edge_prob_decomp}
    \caption{Relative Schnittkosten für die Heuristik GraphEdgeProb und Hierarchical Decomposition in Abhängikeit von $\eps$}
\end{figure}

%\begin{figure}
%    \centering
%    \includestandalone{figures/graphs/imbalance/pref_attach_rst}
%    \caption{Relative Schnittkosten für die Heuristik Preferrential Attachment und RST in Abhängikeit von $\eps$}
%\end{figure}
%
%\begin{figure}
%    \centering
%    \includestandalone{figures/graphs/imbalance/pref_attach_mst}
%    \caption{Relative Schnittkosten für die Heuristik Preferrential Attachment und MST in Abhängikeit von $\eps$}
%\end{figure}

\begin{figure}
    \centering
    \includestandalone{figures/graphs/imbalance/pref_attach_decomp}
    \caption{Relative Schnittkosten für die Heuristik Preferrential Attachment und Hierarchical Decomposition in Abhängikeit von $\eps$}
\end{figure}
