% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.
\newcommand{\Cpp}{C{}\texttt{++}}

\chapter{Implementierung}\label{chapter:implementierung}
In diesem Kapitel wird die Implementierung des Algorithmus beschrieben, der in Kapitel~\ref{chapter:theorie} präsentiert wurde.
Zuerst wird darauf eingegangen, welche Drittmaterialien, also Programmiersprache, Build-System und Softwarebibliotheken, verwendet wurden.
Danach wird erläutert wird anhand von Pseudocode erläutert, wie der Algorithmus als Programm umgesetzt wurde. 
\todo[inline]{Danach Datenstrukturen, Zuletzt evtl. noch einzelne \Cpp\hyp Ausschnitte} 

\section{Drittmaterialien}
\paragraph{\Cpp}
Der Quellcode der Implementierung wurde in der Programmiersprache \Cpp{} verfasst.
Diese Programmiersprache wurde ausgewählt, da sie maschinennahe Programmierung zulässt und eine umfangreiche Standardbibliothek anbietet.
Weiterhin ist \Cpp{} eine der beliebtesten Programmiersprachen~\parencite{TIO17}, wodurch auch ein reichhaltiges Angebot an Entwicklerwerkzeugen und Dokumentation zur Verfügung steht.

\paragraph{Craftr}
Um den Quellcode zu kompilieren, wird das Meta-Build-System Craftr verwendet.
Craftr ist auf Github\footnote{URL des Repositoriums: \url{https://github.com/craftr-build/craftr}} verfügbar und unter den Bedingungen der GPLv3 lizensiert.
Craftr wird in Python3 entwickelt und baut auf das Build-System Ninja\footnote{Internetseite des Build-Systems Ninja: \url{https://ninja-build.org/}} auf. 
Zur Kompilierung des \Cpp\hyp Quellcodes wird die Toolchain Clang\footnote{Webpräsenz der Toolchain Clang: \url{http://clang.llvm.org/}} verwendet.

\paragraph{Google Test}
Google Test ist ein Test-Framework für \Cpp, das eine Vielzahl von Werkzeugen zur Verfügung stellt, um Komponententests durchzuführen. 
Google Test wird auf Github\footnote{https://github.com/google/googletest} entwickelt.
Weiterhin wird Google Test von Craftr unterstützt und wurde mit Hilfe von Craftr eingebunden.

\paragraph{GMP}
Die Bibliothek GMP\footnote{Internetseite der Bibliothek GMP: \url{https://gmplib.org/}} stellt eine effiziente Implementierung von beliebig großen Integern und rationalen Zahlen zur Verfügung.
Rationale Zahlen wurden in dieser Arbeit verwendet, um die Intervallgrenzen der Signaturen zu berechnen, ohne dass numerische Instabilitäten auftreten. 
Die Bibliothek ist mit den Lizenzen LGPLv3 oder GPLv2 verfügbar.
Die \Cpp\hyp Schnitstelle der Bibiliothek machte eine problemlose Einbindung der Bibliothek möglich.

\paragraph{Doxygen}
Doxygen\footnote{Internetpräsenz von Doxygen: \url{http://www.stack.nl/~dimitri/doxygen/}} ist unter der GPLv2 lizensiert und ermöglicht, aus annotierten Quelltextdateien eine HTML\hyp Dokumentation zu generieren.
Auch andere Formate wie Latex oder Postscript werden unterstützt.
Die Dokumentation beschreibt die externen und internen Schnittstellen des Programms, das den Graphpartitionierungsalgorithmus aus dem vorherigem Kapitel implementiert.

\paragraph{HierarchicalDecomposition}
Das Repositorium HierarchicalDecomposition ist auf Github\footnote{URL des Repositoriums: \url{https://github.com/moritzFuchs/hierarchical-decomposition}} zu finden und stellt eine Implementierung eines Graphdekompositionsalgorithmus von Räcke, Shah und Täubig~\parencite{RST14} bereit.
Im Gegensatz zu den Ergebnissen aus Satz~\ref{thm:decomptrees} gibt dieser Algorithmus nur einen einzigen Dekompositionsbaum aus und erreicht dabei einen Approximationsfaktor $\bigO(\log^4 n)$.
Mit diesem Algorithmus ist es möglich, einen Dekompositionsbaum für einen Graphen zu generieren und den Algorithmus dieser Arbeit auf den Dekompositionsbaum anzuwenden.

\paragraph{METIS}
Die Software METIS von Karypis und Kumar~\cite{KK98} benutzt einen heuristischen Ansatz, um eine $(k, 1 + \eps)$\hyp Partitionierung zu finden. 
Dabei wird der Graph iterativ verkleinert, indem Kanten kontrahiert werden.
Im verkleinerten Graph wird dann eine Partitionierung berechnet.
Danach wird der Graph wieder schrittweise expandiert, wobei in jedem Schritt lokale Verbesserungen der Partitionierung vorgenommen werden.
In dieser Arbeit wird METIS verwendet, um die Lösungsqualität des implementierten Algorithmus abschätzen zu können.

\paragraph{KaHIP}
So ähnlich wie METIS handelt es sich bei KaHIP um eine Heuristik von Sanders und Schulz~\cite{SS13}, um eine $(k, 1 + \eps)$\hyp Partitionierung zu finden.
Auch hier werden Kanten zunächst kontrahiert und anschließend wieder expandiert.
Allerdings verwendet KaHIP andere Heuristiken, um die Partitionierung während dem Expandieren zu verbessern.

\section{Algorithmus}
In Sektion~\ref{sec:treepartitioning} wurde ein Überblick gegeben, wie das $(k,1+\eps)$\hyp Partitionierungsproblem auf Bäumen approximiert werden kann. 
Der Algorithmus ist zweiphasig und besteht aus einer Schnittphase und einer Packphase.
Im Folgenden wird auf die Implementierung dieser Phasen eingegangen, welche in Sektion~\ref{sec:cutting} beziehungsweise~\ref{sec:packing} erläutert wurden.
Zuletzt werden die Ergebnisse der Schnittphase und der Packphase zusammengeführt.

\subsection{Schnittphase}
\todo[inline]{Zeiten}
Sei $T=(V,E)$ ein Baum mit Wurzel $r$.
In der Schnittphase, die in Sektion~\ref{sec:cutting} beschrieben wurde, wird eine Menge von Äquivalenzklassen berechnet, wobei jede Äquivalenzklasse eine Möglichkeit darstellt, $T$ in Komponenten bestimmter Größe zu zerschneiden.
Jede dieser Äquivalenzklassen wird nach Definition~\ref{defn:signature} durch eine Signatur repräsentiert.
Um diese Signaturen zu berechnen, wird dynamische Programmierung verwendet, welche durch die Rekursionsgleichungen~\eqref{eq:e_not_cut} und~\eqref{eq:e_cut} gegeben ist.
Aus diesen Rekursionsgleichungen wird ersichtlich, dass für die Berechnungen der Signaturen an einem Knoten $v \neq r$ die Signaturen an seinem rechtestem Kind $u$ und an seinem linken Geschwisterknoten $w$ benötigt werden.
Im Folgenden wird beschrieben, wie der Baum traversiert werden kann, so dass die Signaturen an $u$ und $w$ bereits berechnet sind, wenn $v \neq r$ betrachtet wird. 
Dafür wird zunächst der Begriff Level definiert. \\

\begin{defn}[Level]\label{def:level}
    Sei $T = (V,E)$ ein Baum mit Wurzel $r$ und sei für jeden Knoten $v \in V$ eine Ordnung seiner Kindknoten gegeben.
    Ein Level $L_T(l)$ ist als die Menge aller Knoten, die eine Distanz von $l$ zu $r$ haben.
    Die Knoten in $L_T(l)$ erhalten eine Ordnung, die sich aus der Ordnung der Kindknoten ableitet.
\end{defn}

Beginnend mit Level $k$ werden alle Level bis Level $1$ durchlaufen.
Danach wird noch die Wurzel $r$ betrachtet, welche der einzige Knoten im Level $0$ ist. 
In jedem Level werden die Knoten hinsichtlich ihrer Ordnung besucht.
Da die Ordnung der Geschwisterknoten in einem Level erhalten bleibt, wird der linke Geschisterknoten $w$ von $v$ besucht, bevor $v$ betrachtet wird.
Weiterhin werden durch dieses Verfahren vor $v$ alle Kinder von $v$ besucht, da die Distanz der Kinder von $v$ zu~$r$ echt größer ist als die Distanz von $v$~zu~$r$.
Das oben beschriebene Iterationsschema wird durch Algorithmus~\ref{alg:iteration} formalisiert.

\begin{algorithm}
    \caption{Iterationsschema der Schnittphase}\label{alg:iteration}
    \begin{algorithmic}[1]
        \Let{$k$}{$\max_{L_T(l) \neq \emptyset} l$} \Comment{Wie wird das Maximum korrekt geschrieben?}
        \For{$l \in \{k, k - 1, \ldots, 1\}$}
            \ForAll{$v \in L_T(l)$} \Comment{Die Knoten werden ihrer Ordnung nach durchlaufen.}
                \State \Call{cut\_at\_node}{$v$}
            \EndFor
        \EndFor
        \ForAll{$v \in L_T(0)$} \Comment{$L_T(0) = \{r\}$}
            \State \Call{cut\_at\_root}{$v$}
        \EndFor
    \end{algorithmic}
\end{algorithm}

\newcommand{\canfun}{\textproc{cut\_at\_node}}
\newcommand{\carfun}{\textproc{cut\_at\_root}}

Der Algorithmus~\ref{alg:iteration} verwendet die Funktionen \canfun{} und \carfun{}.
Zuerst wird die Implementierung der Funktion \canfun{} betrachtet, welche am Knoten $v \neq r$ für alle Knotenanzahlen $m \in \nats_0$ und für alle Signaturen $\vec{g} \in \nats_0^t$ die Schnittkosten $C_v(\vec{g}, m)$ berechnet.
Hierbei gilt $t = \ceil{\log_{1+\eps}(1/\eps)} + 1$ nach Definition~\ref{defn:signature}.
Die Kostenfunktion $C_v : \nats_0^t \times \nats_0 \rightarrow \reals_{\geq 0} \cup \{\infty\}$ weist dem Paar $(\vec{g}, m)$ den Wert $\infty$ zu, falls die Signatur $\vec{g}$ mit Knotenanzahl $m$ am Knoten $v$ nicht erreicht werden kann.
Wir führen die Notation $C^m_v(\vec{g}) \coloneqq C_v(\vec{g}, m)$ ein.
Dann können wir $C_v$ als eine Tabelle $T(C_v)$ speichern, die das Schlüssel-Wert-Paar $(m,C^m_v)$ genau dann enthält, wenn eine Signatur $\vec{g}$ existiert, sodass $C^m_v(\vec{g}) < \infty$.
Umgekehrt gilt $C_v(\vec{g}, m) = \infty$ für alle $\vec{g}$, falls der Schlüssel $m$ nicht in $T(C_v)$ ist.
Des Weiteren wird $C_v^m$ für alle Schlüssel $m$ in $T(C_v)$ auch als Tabelle abgespeichert.
Dabei enthält $T(C_v^m)$ das Schlüssel-Wert-Paar $(\vec{g}, c)$ genau dann, wenn $c < \infty$.

Nun betrachten wir, wie die Rekursionsgleichungen~\eqref{eq:e_not_cut} und~\eqref{eq:e_cut} verwendet werden, um die Tabelle $T(C_v)$ für einen Knoten $v \neq r$ zu berechnen.
Sei im Folgenden $w$ der linke Geschwisterknoten von $v$ und $u$ das rechteste Kind von $v$.
Aus den Gleichungen wird ersichtlich, dass sich die Kosten $C_v$ aus den Kosten $C_w$ und $C_u$ sowie dem Gewicht $w(v, p)$ der Kante von $v$ zu seinem Elternknoten $p$ berechnen.
Wir wissen, dass nicht-unendliche Schnittkosten immer erreicht werden können, indem alle Kanten geschnitten werden.
Deshalb müssen wir nur die Kombinationen aus Knotenanzahlen und Signaturen in $C_w$ und $C_u$ betrachten, die zu Schnittkosten kleiner als unendlich führen und damit in den Tabellen $T(C_w)$ und $T(C_u)$ enthalten sind.
Wir erinnern uns, dass $C_x((0,\ldots, 0),0) = 0$ für alle $x$ gilt, auch wenn $x$ im Baum $T$ nicht existiert.
Daraus folgt, dass die Tabelle $T(C_x)$ und die Tabelle $T(C^0_x)$ für einen nicht existenten Knoten $x$ jeweils genau einen Eintrag haben, nämlich $(0, T(C^0_x))$ beziehungsweise $((0,\ldots,0), 0)$.
Insgesamt erhalten wir das Iterationsschema in Algorithmus~\ref{alg:canfun}.
Dabei ist $T(C).keys$ die Menge aller Schlüssel in der Tabelle $T(C)$ und $T(C_x)[m]$ gibt die Tabelle $T(C^m_x)$ zurück, falls $T(C)$ das Schlüssel-Wert-Paar $(m, T(C^m_x))$ enthält.
Andernfalls gibt $T(C_x)[m]$ eine leere Tabelle zurück.

\begin{algorithm}
    \caption{Implementierung von \canfun{}}\label{alg:canfun}
    \begin{algorithmic}[1]
        \Function{cut\_at\_node}{Node $v$}
        \ForAll{$m_w \in T(C_w).keys$}
            \ForAll{$m_u \in T(C_u).keys$}
                \ForAll{$\vec{g}_w \in T(C_w)[m_w].keys$}
                    \ForAll{$\vec{g}_u \in T(C_u)[m_u].keys$}
                        \State \Call{edge\_not\_cut}{$m_w$, $\vec{g}_w$, $m_u$, $\vec{g}_u$}
                        \State \Call{edge\_cut}{$m_w$, $\vec{g}_w$, $m_u$, $\vec{g}_u$}
                    \EndFor
                \EndFor
            \EndFor
        \EndFor
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\newcommand{\encfun}{\textproc{edge\_not\_cut}}
\newcommand{\ecfun}{\textproc{edge\_cut}}

Da sowohl die Rekursionsgleichung~\eqref{eq:e_not_cut} als auch~\eqref{eq:e_cut} angewendet werden kann, um eine neue Kombination aus Signatur und Knotenanzahl zu erhalten, werden diese beiden Fälle separat durch \encfun{} beziehungsweise \ecfun{} implementiert.
Im ersteren Fall wird die Kante $e$, welche von $v$ zu seinem Elternknoten $p$ geht, nicht geschnitten.
Wie in Sektion~\ref{sec:cutting} erklärt wurde, erhalten wir für diesen Fall die Rekursionsgleichung
\begin{equation*}
    \begin{aligned}
        C_v(\vec{g}, m) = \min \{ & C_w(\vec{g}_w, m - x) + C_u(\vec{g}_u, x) \mid \\
        & \qquad 0 \leq x \leq m \land \vec{g}_w + \vec{g}_u = \vec{g} \}.
    \end{aligned}
    \tag{\ref{eq:e_not_cut} wiederholt}
\end{equation*}

Wir erhalten die Signatur $\vec{g}$ mit $m$ Knoten, indem wir $\vec{g} = \vec{g}_w + \vec{g}_u$ und $m = m_w + m_u$ setzen.
Die Kosten dieser Signatur berechnen sich durch die Summe von $C_w(\vec{g}_w, m_w)$ und $C_u(\vec{g}_u, m_u)$.
Dementsprechend ist die Rekursionsgleichung in Algorithmus~\ref{alg:encfun} implementiert.
Ähnlich zur vorherigen Schreibweise gilt $T(C_x)[n][\vec{h}] = d$, der Eintrag $(\vec{h}, d)$ in $T(C_x)[n]$ enthalten ist.
Falls dies nicht der Fall ist, gilt $T(C_x)[n][\vec{h}] = \infty$.
Die Zuweisung an $T(C_v)[m][\vec{g}]$ in Zeile~\ref{alg:encfun:line:assign} erstellt die entsprechenden Einträge in den Tabellen $T(C_x)$ und $T(C_x^n)$, wenn diese nicht vorhanden sind.

\begin{algorithm}
    \caption{Implementierung von \textproc{edge\_not\_cut}}\label{alg:encfun}
    \begin{algorithmic}[1]
        \Function{edge\_not\_cut}{Integer $m_w$, Signatur $\vec{g}_w$, Integer $m_u$, Signatur $\vec{g}_u$}
            \Let{$m$}{$m_w + m_u$}
            \Let{$c$}{$T(C_w)[m_w][\vec{g}_w] + T(C_u)[m_u][\vec{g}_u]$}
            \Let{$\vec{g}$}{$\vec{g}_w + \vec{g}_u$}
            \Let{$T(C_v)[m][\vec{g}]$}{$\min\{c, T(C_v)[m][\vec{g}]\}$}\label{alg:encfun:line:assign}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

Im zweiten Fall wird die Kante $e$ geschnitten.
Für diesen Fall wurde in Sektion~\ref{sec:cutting} eine zweite Rekursionsgleichung hergeleitet und es gilt
\begin{equation*}
    \begin{aligned}
        C_v(\vec{g}, m) = \weight(e) + \min \{ & C_w(\vec{g}_w, m - n_v) + C_u(\vec{g}_u, n_v - x) \mid \\ & \qquad 1 \leq x \leq \mu \land \vec{g}_w + \vec{g}_u + \vec{e}(x) = \vec{g} \}. 
    \end{aligned}
    \tag{\ref{eq:e_cut} wiederholt}
\end{equation*}

Da die Kante von $v$ zu seinem Elternknoten geschnitten wird, ist $v$ nicht in der Zusammenhangskomponente, die auch die Wurzel $r$ enthält.
Die Zusammhangskomponente, in der $v$ erhalten ist, besteht ausschließlich aus Knoten des in $v$ gewurzelten Teilbaums und überdeckt zusammen mit den Zusammenhangskomponenten, die durch $\vec{g}_u$ repräsentiert werden, den gesamten Teilbaum.
Deshalb erhalten wir eine Signatur $\vec{g}$ mit $m$ Knoten, indem wir $m = m_w + m_u + (n_v - m_u) = m_w + n_v$ und $\vec{g} = \vec{g}_w + \vec{g}_u + \vec{e}(n_v - m_u)$ setzen, wobei $n_v$ die Anzahl der Knoten des in $v$ gewurzelten Teilbaums ist und $\vec{e}(x)$ die Signatur mit genau einer Zusammenhangskomponente der Größe $x$ beschreibt.
Die Kosten der berechneten Signatur sind dann die addierten Kosten $C_w(\vec{g}_w, m_w)$ und $C_u(\vec{g}_u, m_u)$ plus die Kosten der geschnittenen Kante $e$. 
Insgesamt erhalten wir den Algorithmus~\ref{alg:ecfun}.

\begin{algorithm}
    \caption{Implementierung von \textproc{edge\_cut}}\label{alg:ecfun}
    \begin{algorithmic}[1]
        \Function{edge\_cut}{Integer $m_w$, Signatur $\vec{g}_w$, Integer $m_u$, Signatur $\vec{g}_u$}
            \Let{$x$}{$n_v - m_u$} \Comment{$n_v$ ist die Größe des in $v$ gewurzelten Teilbaums.}
            \If{$x > (1+\eps)\ceil{n/k}$}
                \Return
            \Else
                \Let{$m$}{$x + m_w + m_u$}
                \Let{$p$}{$parent(v)$} \Comment{$parent(v)$ gibt den Elternknoten von $v$ zurück.}
                \Let{$c$}{$\weight(v, p) + T(C_w)[m_w][\vec{g}_w] + T(C_u)[m_u][\vec{g}_u]$} 
                \LineComment{$\vec{e}(x)$ ist die Signatur mit einer Komponente der Größe x.} 
                \Let{$\vec{g}$}{$\vec{e}(x) + \vec{g}_w + \vec{g}_u$} 
                \Let{$T(C_v)[m][\vec{g}]$}{$\min\{c, T(C_v)[m][\vec{g}]\}$}
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{rem}
    In Sektion~\ref{sec:cutting} haben wir den Fall, dass $v$ weder einen linken Geschwisterknoten $w$ noch ein rechtestes Kind $u$ hat, speziell behandelt.
    Für diesen Fall gilt $C_v((0,\ldots,0), 0) = 0)$ und $C_v(\vec{e}(1), 1) = \weight(e)$. 
    Alle anderen Funktionswert sind unendlich.
    Da $w$ und $u$ nicht existieren, haben wir $T(C_w) = T(C_u) = \{(0, \{((0, \ldots, 0), 0)\} \}$.
    Mit diesen Tabellen setzt Algorithmus~\ref{alg:encfun} den Eintrag $T(C_v)[0][(0,\ldots, 0)]$ auf den Wert $0$ und Algorithmus~\ref{alg:ecfun} den Eintrag $T(C_v)[1][\vec{e}(1)]$ auf $\weight(v,p)$, wobei $p$ der Elternknoten von $v$ ist.
    Damit wird dieser Spezialfall bereits durch die oben genannten Algorithmen abgedeckt.
\end{rem}

Der Algorithmus~\ref{alg:canfun} berechnet die Signaturen für alle Knoten $v \neq r$, wobei $r$ die Wurzel des Baums ist.
Um die Schnittphase abzuschließen, wird nun betrachtet, wie die Funktion \carfun{} die Signaturen an der Wurzel $r$ mit der Rekursionsgleichung~\eqref{eq:root} berechnet.
In Sektion~\ref{sec:cutting} wurde festgelegt, dass die Knoten, die nicht durch die Zusammenhangskomponenten in einer Signatur überdeckt werden, eine Zusammenhangskomponente mit der Wurzel $r$ bilden.
Dementsprechend können wir eine Signatur $\vec{g}$ mit $n$ Knoten erhalten, deren Zusammenhangskomponenten alle Knoten im Baum überdecken, wenn wir zu einer Knotenanzahl $x \leq (1+\eps)\ceil{n/k}$ eine Signatur $\vec{g}_u$ mit $m_u = n - x$ Knoten am rechtesten Kind $u$ der Wurzel $r$ finden.
Weiterhin gilt $\vec{g} = \vec{g}_u + \vec{e}(x)$ und die Kosten sind $C_u(\vec{g}_u, m_u)$, da an der Wurzel keine weiteren Kanten geschnitten werden können.
Damit erhalten wir Algorithmus~\ref{alg:carfun}.

\begin{algorithm}
    \caption{Implementierung von \carfun{}}\label{alg:carfun}
    \begin{algorithmic}
        \Function{cut\_at\_root}{Node $r$}
           \For{$x \in \{1, \ldots, (1+\eps)\ceil{n/k}\}$} 
                \ForAll{$(\vec{g}_u, c) \in T(C_u)[n - x]$}
                    \Let{$\vec{g}$}{$\vec{g}_u + \vec{e}(x)$}
                    \Let{$T(C_r)[n][\vec{g}]$}{$\min\{c, T(C_r)[n][\vec{g}]$}\}
                \EndFor
           \EndFor
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\todo[inline]{Bemerkung: Wie wissen wir für eine Signatur welche Kanten geschnitten wurden?}

\subsection{Packphase}
In der vorherigen Sektion wurde beschrieben, wie wir eine Menge von Signaturen und deren Kosten an der Wurzel $r$ berechnen, die alle eine Möglichkeit darstellen den Baum $T$ in Zusammenhangskomponenten zu zerlegen.
Eine Zerlegung in Zusammenhangskomponenten stellt jedoch noch keine Partitionierung von $T$ dar.
Deshalb muss in der Packphase geprüft werden, ob sich die Zusammenhangskomponenten zu einer Signatur $\vec{g}$ in $k$ Behälter der Größe $(1+\eps)\ceil{n/k}$ packen lassen.
Wenn dies der Fall ist, dann können die Zusammenhangskomponenten zu $\vec{g}$ für eine valide Partitionierung verwendet werden.

In Sektion~\ref{sec:packing} wurde ein Approximationsalgorithmus beschrieben, der mit Hilfe dynamischer Programmierung Zusammenhangskomponenten des Baums mit Größe maximal $(1+\eps)\ceil{n/k}$ in Behälter der Größe $(1+\eps)\ceil{n/k}$ packt.
Dafür wurden im ersten Schritt jede Zusammenhangskomponente, deren Größe kleiner als $\eps \ceil{n/k}$ ist, entfernt.
Nach Definition~\ref{defn:signature} sind das genau die Zusammenhangskomponenten, die in einer Signatur $\vec{g} = (g_0, \ldots, g_t)$ mit dem Eintrag $g_0$ gezählt werden.
Deshalb wird im Folgenden der Vektor $(g_1, \ldots, g_t)$ verwendet, um die Anzahl der Komponenten einer bestimmten Größe in der Bin-Packing-Instanz zu zählen.
Da die Komponentgrößen auf die untere Intervallgrenze nach Definition~\ref{defn:signature} abgerundet werden, enthält die Bin-Packing-Instanz $g_i$ Komponenten der Größe $(1+\eps)^{i-1} \cdot \eps \ceil{n/k}$.
Wir definieren den Vektor $\vec{s} = (s_1, \ldots, s_t)$, in dem der Eintrag $s_i$ den Wert $(1+\eps)^{i-1} \cdot \eps \ceil{n/k}$ hat.

Im zweiten Schritt werden die Komponenten, die größer als $\eps \ceil{n/k}$ sind, mit dynamischer Programmierung optimal in Behälter der Größe $\ceil{n/k}$ gepackt.
Um die dynamische Programmierung auszuführen, die durch die Rekursionsgleichung~\eqref{eq:packing} gegeben ist, wird die Menge $\mathcal{C} = \left\{ (c_1, \ldots, c_t) \mid Bins((c_1, \ldots, c_t)) = 1 \right\}$ benötigt.
Dies ist die Menge aller Möglichkeiten einen einzigen Behälter zu füllen, ohne die Kapazität zu verletzen.
Wir bezeichnen im Folgenden einen Vektor $\vec{c} \in \mathcal{C}$ als Behältersignatur.
Wir berechnen die Menge der Behältersignaturen $\mathcal{C}$ schrittweise durch die Mengen $C_i$.
Dabei ist $C_i$ die Menge aller Behältersignaturen, die nur Komponenten verwenden, die von Einträgen $g_1$ bis $g_i$ gezählt werden.
Eine Behältersignatur wird durch das Tupel $(\vec{c}, m_c)$ repräsentiert, wobei $c_i$ die Anzahl der Komponenten der Größe $s_i$ im Behälter zählt und $m_c$ der dadurch gegebenen Füllstand des Behälters ist.
Daraus folgt, dass $C_i$ das Tupel $(\vec{c}, m_c)$ mit $m_c \leq \ceil{n/k}$ genau dann enthält, wenn ein Tupel $(\vec{d}, m_d) \in C_{i-1}$ existiert, sodass $\vec{c} = \vec{d} + k \cdot \vec{e}(s_i)$ und $m_c = m_d + k \cdot s_i$ für ein $k \in \{0, \ldots, g_i\}$.
Hierbei ist $\vec{e}(x)$ die Signatur, die nur eine Komponente der Größe $x$ enthält und deren erste Komponente weggelassen wird.
Für $\mathcal{C}$ gilt dann $\mathcal{C} = \{ \vec{c} \mid (\vec{c}, m_c) \in C_t)\}$.
Mit diesen Ergebnissen erhalten wir Algorithmus~\ref{alg:cabisi}.

\begin{algorithm}
    \caption{Implementierung von \textproc{calculate\_bin\_signatures}}
    \label{alg:cabisi}
    \begin{algorithmic}
        \LineComment{Namensgebung Signatur gut?}
        \Function{calculate\_bin\_signatures}{Signatur $(g_1, \ldots, g_t)$, Vektor $(s_1, \ldots, s_t)$}
            \Let{$C_0$}{$\{(\vec{0}, 0)\}$}
            \For{$i \in \{1, \ldots, t\}$}
                \Let{$C_i$}{$\emptyset$} \Comment{Ist das notwendig?}
                \ForAll{$(\vec{a}, m_a) \in C_{i-1}$}
                    \For{$k \in \{0, \ldots, g_i$\}}
                       \Let{$\vec{b}$}{$\vec{a} + k \cdot \vec{e}(s_i)$} 
                       \Let{$m_b$}{$m_a + k \cdot s_i$}
                       \If{$m_b \leq \ceil{n/k}$}
                            \Let{$C_i$}{$C_i \cup \{(\vec{b}, m_a + m_b)\}$}
                       \EndIf
                    \EndFor
                \EndFor
            \EndFor
            \State{\Return $\{\vec{c} \mid (\vec{c}, m_c) \in C_t\}$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{rem}
    Mit Algorithmus~\ref{alg:cabisi} werden Behältersignaturen $\vec{c}$ berechnet, die Möglichkeiten darstellen einen Behälter mit Komponenten zu füllen.
    Dabei werden auch Behältersignaturen $\vec{c}$ berechnet, die nicht maximal im Sinne davon sind, dass noch Komponenten der Signatur $(g_1 - c_1, \ldots, g_t - c_t)$ zu $\vec{c}$ hinzugefügt werden könnten, ohne die Behälterkapazität zu verletzen.
    Diese wurden in der \Cpp\hyp Implementierung in einem Vorbearbeitungsschritt entfernt, um die Laufzeit zu verbessern.
\end{rem}

Nun können wir die Rekursionsgleichung~\eqref{eq:packing} verwenden, um eine optimale Lösung der Bin-Packing-Instanz zu berechnen, die durch $(g_1, \ldots, g_t)$ und $(s_1, \ldots, s_t)$ gegeben ist.
Dafür bezeichnen wir den aktuellen Zustand eines Packings mit dem Vektor $\vec{p}$, der anfangs nur den Wert $(g_1, \ldots, g_t)$ annehmen kann.
Dann wird iterativ $(\max\{0, p_1 - c_1\}, \ldots, \max\{0, p_t - c_t\})$ für alle Behältersignaturen $\vec{c} \in \mathcal{C}$ berechnet, um neue mögliche Zustände zu erhalten.
Sobald wir das erste Mal bei $\vec{p} = \vec{0}$ ankommen, haben wir alle Komponenten der Signatur $(g_1, \ldots, g_t)$ gepackt.
Indem jeweils der Zustand des vorherigen Schritts zum momentanen Zustand $\vec{p}$ gespeichert wird, kann am Schluss zurückverfolgt werden, welche Behältersignaturen im jeweiligen Schritt verwendet wurden, um die Komponenten in $(g_1, \ldots, g_t)$ zu packen.
Die Algorithmen~\ref{alg:pape} und~\ref{alg:bapa} formalisieren diese Ideen.
\todo[inline]{Ist das ausführlich genug?}

\begin{algorithm}
    \caption{Implementierung von \textproc{pack\_perfect}}
    \label{alg:pape}
    \begin{algorithmic}
        \Function{pack\_perfect}{Signatur $(g_1, \ldots, g_t)$}
            \Let{$\mathcal{C}$}{\Call{calculate\_bin\_signatures}{$(g_1, \ldots, g_t)$, $\vec{s}$}}
            \Let{$P_0$}{$\{(g_1, \ldots, g_t)\}$}
            \For{$i \in \{1, 2, \ldots \}$}
                \Let{$P_i$}{$\emptyset$} \Comment{Ist das notwendig?}
                \ForAll{$\vec{p} \in P_{i-1}$}
                \ForAll{$\vec{c} \in \mathcal{C}$}
                    \Let{$\vec{q}$}{$(\max\{0, p_1 - c_1\}, \ldots, \max\{0, p_t - c_t\})$}
                    \Let{$P_i$}{$P_i \cup \{\vec{q}\}$}
                    \Let{$Prev[i][\vec{q}]$}{$\vec{p}$}
                    \If{$\vec{q} = \vec{0}$} 
                        \State{\Return \Call{backtrack\_packing}{$i$, $Prev$}}
                    \EndIf
                \EndFor
                \EndFor
            \EndFor
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Implementierung von \textproc{backtrack\_packing}}
    \label{alg:bapa}
    \begin{algorithmic}
        \Function{backtrack\_packing}{Integer $k$, Tabelle $Prev$}
            \Let{$\vec{q}$}{$(0, \ldots, 0)$}
            \Let{$L$}{$[]$} \Comment{$L$ wird als leere Liste initialisiert.}
            \For{$i \in \{k, k - 1, \ldots, 1\}$}
                \State{$L.append(Prev[i][\vec{q}] - \vec{q})$} \Comment{$L.append(x)$ hängt $x$ an das Ende von $L$ an.}
                \Let{$\vec{q}$}{$Prev[i][\vec{q}]$} 
            \EndFor
            \State{\Return $L$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\todo{Ausführlicher?} Im dritten Schritt werden im Packing, welches wir mit der Funktion \textproc{pack\_perfect} berechnen können, die ursprünglichen Größen der Zusammenhangskomponenten der Signatur $(g_1, \ldots, g_t)$ wiederhergestellt. 
Gleichzeitig wird die Kapazität der Behälter auf $(1+\eps)\ceil{n/k}$ erhöht.
Zuletzt werden noch die restlichen Komponenten $g_0$ mit einer Größe kleiner als $\eps \ceil{n/k}$ greedy mit First-Fit gepackt.
\todo{Begründung für diese Implementierung?} Dieses Verfahren wurde naiv implementiert, das heißt es wird für jede dieser Komponenten über alle Behälter iteriert, bis ein Behälter gefunden wird, in dem noch Platz ist.
Existiert kein solcher Behälter wird ein neuer erstellt.

\subsection{Partitionierung}

\section{Datenstrukturen}
\subsection{Bäume und Knoten}
Listing~\ref{lst:structnode} zeigt, wie ein Knoten definiert ist.
\begin{lstlisting}[caption={Definition von \texttt{struct Node}}, label={lst:structnode}]
struct Node {
    public:
        IdType const id;
        EdgeWeightType const parent_edge_weight;
        size_t const parent_idx;
        std::pair<size_t const, size_t const> const children_idx_range;
    }
\end{lstlisting}
\todo[inline]{Listings besprechen}

Hierbei sind die Typen \texttt{IdType} und \texttt{EdgeWeightType} Integer.
Ein Knoten $v$ wird durch eine Integer-ID identifiziert. 
Weiterhin speichert $v$ das Gewicht der Kante, die zu seinem Elternknoten führt, im Feld \texttt{parent\_edge\_weight}.
Die Felder \texttt{parent\_idx} und \texttt{children\_idx\_range} werden verwendet, um die Struktur des Baums abbzubilden.
Wenn $v$ im Level $l$ liegt, dann speichert das Feld \texttt{parent\_idx} den Index des Elternknotens im Level $l-1$, während das Feld \texttt{children\_idx\_range} die Indices der Kinder von $v$ im Level $l+1$ speichert.
Das Feld \texttt{children\_idx\_range} stellt einen rechtsexklusiven Bereich dar, was unter anderem bedeutet, dass $v$ genau dann keine Kinder hat, wenn die beiden Indices des Bereichs gleich sind.
Ein Baum verwendet dann diese Definition eines Knotens, wie in Listing~\ref{lst:structtree} zu sehen ist.

\begin{lstlisting}[caption={Definition von \texttt{struct Tree}}, label={lst:structtree}]
struct Tree {
    public:
        std::vector<std::vector<Node>> levels;
        std::vector<std::vector<bool>> has_left_sibling;
        std::vector<std::vector<SizeType>> tree_sizes;
    }
\end{lstlisting}
\todo{Evtl. die Typendefinitionen für SizeType etc. auch zeigen?} Hierbei ist \texttt{SizeType} der Integertyp, der verwendet wird, um Knoten zu zählen.
Um das Traversieren des Baums zu vereinfachen, werden die Knoten des Baums in Leveln gespeichert.
Da jedes Level als \texttt{std::vector<Node>} abgespeichert wird, haben die Knoten innerhalb eines Levels eine Ordnung.
Die Felder \texttt{has\_left\_sibling} und \texttt{tree\_sizes} haben diesselbe Struktur wie \texttt{levels} und dienen als Lookup-Tabellen.
Wenn der Knoten $v$ an der Stelle \texttt{levels[i][j]} abgespeichert ist, dann gibt uns der Lookup \texttt{tree\_sizes[i][j]} die Größe des Teilbaums gewurzelt in $v$ und \texttt{has\_left\_sibling[i][j]}, ob $v$ einen linken Geschisterknoten hat.
Wenn wir den Baum mit dem oben beschriebenen Verfahren traversieren, dann verspricht diese Implementierung eine hohe Cacheeffizienz, da die Knoten in einem Level in der selben Reihenfolge besucht werden, wie sie im Speicher abgelegt sind.

\subsection{Signaturen}
Um in der Schnittphase die Äquivalenzklassen zu berechnen, werden diese nach Definition~\ref{defn:signature} durch eine Signatur repräsentiert.
Eine Signatur ist ein Vektor mit der Länge $t = \ceil{\log_{1+\eps}(1/\eps)} + 1$ und enthält ausschließlich nicht-negative Integer.
Weiterhin folgt aus den Rekursionsgleichungen~\eqref{eq:e_not_cut} und~\eqref{eq:e_cut}, dass Vektoradditionen durchgeführt werden müssen.
In der Standardbibliothek von \Cpp{} gibt es dafür den Container \texttt{valarray}, der ein Array fester Länge ist und zusätzlich noch mathematische Operationen, darunter auch komponentenweise Addition, zulässt. 
Das Listing~\ref{lst:signature} zeigt, wie eine Signatur im \Cpp\hyp Code definiert ist.
\begin{lstlisting}[caption={Definition von \texttt{Signature}}, label={lst:signature}]
using Signature = std::valarray<SizeType>;
\end{lstlisting}

Außerdem muss an jedem Knoten $v$ die Abbildung $C_v : \mathbb{N}_0 \times \mathbb{N}^t_0 \rightarrow \reals_{\geq 0} \cup \{\infty\}$, welche einer Anzahl von Knoten und einer Signatur die minimalen Schnittkosten zuweist.
Im Folgenden wird die Notation $C_v(m)$ verwendet, um die Abbildung $C_v(m) : \mathbb{N}^t_0 \rightarrow \reals_{\geq 0} \cup \{\infty\}$ zu beschreiben, welche eine Signatur für eine gegeben Anzahl an Knoten $m$ auf die minimalen Schnittkosten abbildet.
Da unendliche Schnittkosten bedeuten, dass eine Signatur nicht erreicht werden kann, können wir anstattdessen die Abbildung $C_v^\prime(m) : \mathbb{N}_0 \times \mathcal{S}_v(m) \rightarrow \reals_{\geq 0}$ speichern, wobei $\mathcal{S}_v(m)$ die Menge aller Signaturen ist, die am Knoten $v$ mit $m$ Knoten in der Signatur möglich sind.
Den Signaturen, die am Knoten $v$ nicht erreicht werden können, wird dann implizit eine Wert von $\infty$ zugewiesen.
Da die Kardinalität von $\mathcal{S}_v$ mit Gleichung~\eqref{eq:sigcount} polynomiell in $n$ und $k$ beschränkt ist, können wir die Abbildung $C_v^\prime$ als Tabelle abspeichern.
Eine Möglichkeit eine Tabelle zu speichern ist ein balancierter Suchbaum, wobei die Elemente anhand der lexikographischen Größe der Signaturen sortiert werden.
Die Rekursionsgleichungen~\eqref{eq:e_not_cut} und~\eqref{eq:e_cut} verlangen, dass von allen Möglichkeiten, eine Signatur zu erreichen, diejenige ausgewählt wird, welche die geringsten Schnittkosten verursacht.
Das bedeutet, dass für jede Signatur, die am Knoten $v$ berechnet wird, geprüft werden muss, ob diese Signatur bereits in der Tabelle eingetragen ist.
Wenn die Signatur bereits einmal berechnet wurde, dann wird das Minimum der Schnittkosten der beiden Signaturen gewählt; andernfalls wird eine neuer Eintrag in der Tabelle für diese Signatur eingefügt.
In einem balancierten Suchbaum beansprucht jede dieser Überprüfungen eine logarithmische Laufzeit in der Anzahl der Signaturen in der Tabelle, wenn der lexikographische Vergleich zweier Signaturen in konstanter Zeit durchgeführt werden kann.
Der lexikographische Vergleich hat konstante Laufzeit, da die Signaturen für konstantes $\eps$ eine konstante Länge haben.
Die Tabelle wurde jedoch mit einer Hashtabelle implementiert, da dies die Laufzeit verbessert.

\subsection{Packing}

\section{Verwendung}
Kompilieren des Programms, Interaktion mit dem Programm
