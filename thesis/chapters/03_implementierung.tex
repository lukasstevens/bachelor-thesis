% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.
\newcommand{\Cpp}{C{}\texttt{++}}

\chapter{Implementierung}\label{chapter:implementierung}
In diesem Kapitel wird die Implementierung des Algorithmus beschrieben, der in Kapitel~\ref{chapter:theorie} präsentiert wurde.
Zuerst wird darauf eingegangen, welche Drittmaterialien, also Programmiersprache, Build-System und Softwarebibliotheken, verwendet wurden.
Danach werden die Datenstrukturen erläutert, die benötigt wurden, um den Algorithmus als Programm umzusetzten.
Zuletzt wird beschrieben, wie der Algorithmus in Code übersetzt wurde.

\section{Drittmaterialien}
\paragraph{\Cpp}
Der Quellcode der Implementierung wurde in der Programmiersprache \Cpp\ verfasst.
Diese Programmiersprache wurde ausgewählt, da sie maschinennahe Programmierung zulässt und eine umfangreiche Standardbibliothek anbietet.
Weiterhin ist \Cpp\ eine der beliebtesten Programmiersprachen~\parencite{TIO17}, wodurch auch ein reichhaltiges Angebot an Entwicklerwerkzeugen und Dokumentation zur Verfügung steht.

\paragraph{Craftr}
Um den Quellcode zu kompilieren, wird das Meta-Build-System Craftr verwendet.
Craftr ist auf Github\footnote{URL des Repositoriums: \url{https://github.com/craftr-build/craftr}} verfügbar und unter den Bedingungen der GPLv3 lizensiert.
Craftr wird in Python3 entwickelt und baut auf das Build-System Ninja\footnote{Internetseite des Build-Systems Ninja: \url{https://ninja-build.org/}} auf. 
Zur Kompilierung des \Cpp\hyp Quellcodes wird die Toolchain Clang\footnote{Webpräsenz der Toolchain Clang: \url{http://clang.llvm.org/}} verwendet.

\paragraph{Google Test}
Google Test ist ein Test-Framework für \Cpp, das eine Vielzahl von Werkzeugen zur Verfügung stellt, um Komponententests durchzuführen. 
Google Test wird auf Github\footnote{https://github.com/google/googletest} entwickelt.
Weiterhin wird Google Test von Craftr unterstützt und wurde mit Hilfe von Craftr eingebunden.

\paragraph{GMP}
Die Bibliothek GMP\footnote{Internetseite der Bibliothek GMP: \url{https://gmplib.org/}} stellt eine effiziente Implementierung von beliebig großen Integern und rationalen Zahlen zur Verfügung.
Rationale Zahlen wurden in dieser Arbeit verwendet, um numerische Instabilität aufgrund von Fließkommaberechnungen auszuschließen.
Die Bibliothek ist mit den Lizenzen LGPLv3 oder GPLv2 verfügbar.
Die \Cpp\hyp Schnitstelle der Bibiliothek machte eine problemlose Einbindung der Bibliothek möglich.

\paragraph{Doxygen}
Doxygen\footnote{Internetpräsenz von Doxygen: \url{http://www.stack.nl/~dimitri/doxygen/}} ist unter der GPLv2 lizensiert und ermöglicht, aus annotierten Quelltextdateien eine HTML\hyp Dokumentation zu generieren.
Auch andere Formate wie Latex oder Postscript werden unterstützt.
Die Dokumentation beschreibt die externen und internen Schnittstellen des Programms, das den Graphpartitionierungsalgorithmus aus dem vorherigem Kapitel implementiert.

\paragraph{HierarchicalDecomposition}
Das Repositorium HierarchicalDecomposition ist auf Github\footnote{URL des Repositoriums: \url{https://github.com/moritzFuchs/hierarchical-decomposition}} zu finden und stellt eine Implementierung eines Graphdekompositionsalgorithmus von Räcke, Shah und Täubig~\parencite{RST14} bereit.
Im Gegensatz zu den Ergebnissen aus Satz~\ref{thm:decomptrees} gibt dieser Algorithmus nur einen einzigen Dekompositionsbaum aus und erreicht dabei einen Approximationsfaktor $\bigO(\log^4 n)$.
Mit diesem Algorithmus ist es möglich, einen Dekompositionsbaum für einen Graphen zu generieren und den Algorithmus dieser Arbeit auf den Dekompositionsbaum anzuwenden.

\paragraph{METIS}
Die Software METIS von Karypis und Kumar~\cite{KK98} benutzt einen heuristischen Ansatz, um das $(k, 1 + \eps)$\hyp Partitionierungsproblem zu lösen. 
Dabei wird der Graph iterativ verkleinert, indem Kanten kontrahiert werden.
Im verkleinerten Graph wird dann eine Partitionierung berechnet.
Danach wird der Graph wieder schrittweise expandiert, wobei in jedem Schritt lokale Verbesserungen der Partitionierung vorgenommen werden.
In dieser Arbeit wird METIS verwendet, um die Lösungsqualität des implementierten Algorithmus abschätzen zu können.

\paragraph{KaHIP}
So ähnlich wie METIS handelt es sich bei KaHIP um eine Heuristik von Sanders und Schulz~\cite{SS13}, um das $(k, 1 + \eps)$\hyp Partitionierungsproblem zu lösen.
Auch hier werden Kanten zunächst kontrahiert und anschließend wieder expandiert.
Allerdings verwendet KaHIP andere Heuristiken, um die Partitionierung während dem Expandieren zu verbessern.

\section{Datenstrukturen}
\subsection{Bäume und Knoten}
In Sektion~\ref{sec:treepartitioning} wurde ein Überblick gegeben, wie das $(k,1+\eps)$\hyp Partitionierungsproblem auf Bäumen approximiert werden kann. 
In der Schnittphase, die in Sektion~\ref{sec:cutting} beschrieben wurde, wird eine Menge von Äquivalenzklassen berechnet, wobei jede Äquivalenzklasse eine Möglichkeit darstellt, den Baum in Komponenten bestimmter Größe zu zerschneiden.
Um diese Menge von Äquivalenzklassen zu berechnen, wird dynamische Programmierung verwendet.
Die dynamische Programmierung ist durch die Rekursionsgleichungen~\eqref{eq:e_not_cut} und~\eqref{eq:e_cut} gegeben.
Aus diesen Rekursionsgleichungen wird ersichtlich, dass für die Berechnungen der Signaturen an einem Knoten $v$ die Signaturen an seinem rechtestem Kind $u$ und an seinem linken Geschwisterknoten $w$ benötigt werden.
Im Folgenden wird beschrieben, wie der Algorithmus den Baum traversiert, so dass die Signaturen an $u$ und $w$ bereits berechnet sind, wenn $v$ betrachtet wird. 
Sei $T=(V,E)$ ein Baum mit Wurzel $r$.
Für jeden Knoten in $V$ legen wir eine Ordnung seiner Kindknoten fest.
\todo{Vlt. als Definition} Dann ist das Level $l$ von $T$ als die Menge aller Knoten definiert, die eine Distanz von $l$ zu $r$ haben. 
Die Knoten in Level $l$ erhalten eine Ordnung, die sich von der oben genannten Ordnung ableitet.
Sei $k$ die maximalen Distanz zur Wurzel $r$ über alle Knoten in $V$.
Dann startet der Algorithmus beim Level $k$ und durchläuft alle Level bis er bei Level $0$ ankommt.
In jedem Level werden die Knoten hinsichtlich ihrer Ordnung besucht.
Da die Ordnung der Geschwisterknoten in einem Level erhalten wird, besucht der Algorithmus den linken Geschisterknoten $w$ von $v$, bevor er $v$ besucht.
Weiterhin werden durch dieses Verfahren vor $v$ alle Kinder von $v$ besucht, da die Distanz der Kinder von $v$ zu $r$ echt größer ist als die Distanz von $v$ zu $r$.
Listing~\ref{lst:structnode} zeigt, wie ein Knoten gemäß der vorangegangenen Überlegungen definiert ist.

\begin{lstlisting}[caption={Definition von \texttt{struct Node}}, label={lst:structnode}]
struct Node {
    public:
        IdType const id;
        EdgeWeightType const parent_edge_weight;
        size_t const parent_idx;
        std::pair<size_t const, size_t const> const children_idx_range;
}
\end{lstlisting}
\todo[inline]{Listings besprechen}

Hierbei sind die Typen \texttt{IdType} und \texttt{EdgeWeightType} Integer.
Ein Knoten $v$ wird durch eine Integer-ID identifiziert. 
Weiterhin speichert $v$ das Gewicht der Kante, die zu seinem Elternknoten führt, im Feld \texttt{parent\_edge\_weight}.
Die Felder \texttt{parent\_idx} und \texttt{children\_idx\_range} werden verwendet, um die Struktur des Baums abbzubilden.
Wenn $v$ im Level $l$ liegt, dann speichert das Feld \texttt{parent\_idx} den Index des Elternknotens im Level $l-1$, während das Feld \texttt{children\_idx\_range} die Indices der Kinder von $v$ im Level $l+1$ speichert.
Das Feld \texttt{children\_idx\_range} stellt einen rechtsexklusiven Bereich dar, was unter anderem bedeutet, dass $v$ genau dann keine Kinder hat, wenn die beiden Indices des Bereichs gleich sind.
Ein Baum verwendet dann diese Definition eines Knotens, wie in Listing~\ref{lst:structtree} zu sehen ist.

\begin{lstlisting}[caption={Definition von \texttt{struct Tree}}, label={lst:structtree}]
struct Tree {
    public:
        std::vector<std::vector<Node>> levels;
        std::vector<std::vector<bool>> has_left_sibling;
        std::vector<std::vector<SizeType>> tree_sizes;
}
\end{lstlisting}
\todo{Evtl. die Typendefinitionen für SizeType etc. auch zeigen?} Hierbei ist \texttt{SizeType} der Integertyp, der verwendet wird, um Knoten zu zählen.
Um das Traversieren des Baums zu vereinfachen, werden die Knoten des Baums in Leveln gespeichert.
Da jedes Level als \texttt{std::vector<Node>} abgespeichert wird, haben die Knoten innerhalb eines Levels eine Ordnung.
Die Felder \texttt{has\_left\_sibling} und \texttt{tree\_sizes} haben diesselbe Struktur wie \texttt{levels} und dienen als Lookup-Tabellen.
Wenn der Knoten $v$ an der Stelle \texttt{levels[i][j]} abgespeichert ist, dann gibt uns der Lookup \texttt{tree\_sizes[i][j]} die Größe des Teilbaums gewurzelt in $v$ und \texttt{has\_left\_sibling[i][j]}, ob $v$ einen linken Geschisterknoten hat.
Wenn wir den Baum nach dem oben gegeben Verfahren traversieren, dann verspricht diese Implementierung eine hohe Effizienz des Caches, da jedes Level des Baums ein \texttt{std::vector<Node>} ist und die Knoten daher hintereinander im Speicher abgelegt sind.

\subsection{Signaturen}
Um in der Schnittphase die Äquivalenzklassen zu berechnen, werden diese nach Definition~\ref{defn:signature} durch eine Signatur repräsentiert.
Eine Signatur ist ein Vektor mit der Länge $t = \ceil{\log_{1+\eps}(1/\eps)} + 1$ und enthält ausschließlich nicht-negative Integer.
Weiterhin folgt aus den Rekursionsgleichungen~\eqref{eq:e_not_cut} und~\eqref{eq:e_cut}, dass Vektoradditionen durchgeführt werden müssen.
In der Standardbibliothek von \Cpp\ gibt es dafür den Container \texttt{valarray}, der ein Array fester Länge ist und zusätzlich noch mathematische Operationen, darunter auch komponentenweise Addition, zulässt. 
Das Listing~\ref{lst:signature} zeigt, wie eine Signatur im \Cpp\hyp Code definiert ist.
\begin{lstlisting}[caption={Definition von \texttt{Signature}}, label={lst:signature}]
using Signature = std::valarray<SizeType>;
\end{lstlisting}

Außerdem muss an jedem Knoten $v$ die Abbildung $C_v : \mathbb{N}^t_0 \rightarrow \reals_{\geq 0} \cup \{\infty\}$, welche einer Signatur ihre minimalen Schnittkosten zuweist, gespeichert und berechnet werden.
Wenn die minimalen Schnittkosten unendlich sind, dann ist es nicht möglich diese Signatur am Knoten $v$ zu erreichen.
Wir können diese Eigenschaft nutzen und anstattdessen die Abbildung $C_v^\prime : \mathcal{S}_v \rightarrow \reals_{\geq 0}$ speichern, wobei $\mathcal{S}_v$ die Menge aller Signaturen ist, die am Knoten $v$ möglich sind.
Den Signaturen, die am Knoten $v$ nicht erreicht werden können, wird dann implizit eine Wert von $\infty$ zugewiesen.
Um $C^\prime_v$ zu speichern, müssen wir festlegen, wie die Menge von Signaturen $\mathcal{S}_v$ gespeichert wird.



\subsection{Packing}

\section{Algorithmus}
\subsection{Schnittphase}
\subsection{Packphase}
\subsection{Partitionierung}
\section{Verwendung}
Kompilieren des Programms, Interaktion mit dem Programm
